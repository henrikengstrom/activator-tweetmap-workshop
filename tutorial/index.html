<html>
<head>
    <title>Tweetmap Workshop - Activator Template</title>
</head>
<body>
<div>
    <p>Welcome to the Tweetmap Workshop! You've just created a simple Play Framework application! We will use this as
        the starting template for the Tweetmap Workshop.</p>

    <h2>View the App</h2>

    <p>
        Once the application has been compiled and the server started, your application can be accessed at: <a
            href="http://localhost:9000" target="_blank">http://localhost:9000</a><br/>
        Check in <a href="#run" class="shortcut">Run</a> to see the server status.<br/>
    </p>
</div>
<div>
    <h2>Reactive Requests</h2>

    <p>
        <ul>
            <li>Routes</li>
            <li>Controllers</li>
            <li>Views</li>
            <li>Reactive Requests</li>
            <li>JSON</li>
        </ul>
    </p>

    <p>1. Update the <a href="#code/conf/routes" class="shortcut">routes</a> file with the following routes:</p>

    <p>GET   &nbsp;&nbsp /        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; controllers.Tweets.index</p>
    <p>GET   &nbsp;&nbsp /tweets  &nbsp;&nbsp;&nbsp;&nbsp; controllers.Tweets.search(query: String)</p>

<p></p>
<p>2. Create a new Controller by creating a new Tweets.scala file in <a href="#code/app/controllers" class="shortcut">app/controllers</a>:</p>
<p></p>
 <pre><code>
     package controllers

     import play.api.mvc.{Action, Controller}
     import scala.concurrent.Future
     import play.api.libs.json.{JsValue, Json}
     import play.api.libs.ws.WS
     import play.api.libs.concurrent.Execution.Implicits.defaultContext

     object Tweets extends Controller {

         def index = Action { implicit request =>
            Ok(views.html.index("TweetMap"))
         }

         def search(query: String) = Action.async {
            fetchTweets(query).map(tweets => Ok(tweets))
         }

         def fetchTweets(query: String): Future[JsValue] = {
             val tweetsFuture = WS.url("http://twitter-search-proxy.herokuapp.com/search/tweets").withQueryString("q" -> query).get()
             tweetsFuture.map { response =>
                response.json
             } recover {
                case _ => Json.obj("responses" -> Json.arr())
             }
         }

     }
 </code></pre>

    <p>3. Test it: <a href="http://localhost:9000/tweets?query=typesafe" target="_blank">http://localhost:9000/tweets?query=typesafe</a></p>
    <p></p>
</div>

<div>
    <h2>CoffeeScript Asset Compiler</h2>
    <ul>
        <li>Asset Compiler</li>
        <li>Bootstrap</li>
        <li>CoffeeScript</li>
    </ul>


    <p>1. Update the <a href="#code/app/views/main.scala.html" class="shortcut">main.scala.html</a> file replacing the contents of <pre><code> &ltdiv class="container-fluid"&gt </code></pre> with:

    <pre><code>
        &lt;a href="#" class="brand pull-left"&gt;@title&lt;/a&gt;
        &lt;form id="queryForm" class="navbar-search pull-left"&gt;
        &lt;input id="twitterQuery" name="twitterQuery" type="text" class="search-query" placeholder="Search"&gt;
        &lt;/form&gt;
    </code></pre>


    <p>2. Replace the contents of the <a href="#code/app/views/index.scala.html" class="shortcut">index.scala.html</a> file:</p>

    <pre><code>
        @(message: String)(implicit request: RequestHeader)

        @main(message) {

        &ltscript type='text/javascript' src='@routes.Assets.at("javascripts/index.min.js")'&gt&lt/script&gt

        &ltul id="tweets"&gt&lt/ul&gt

        }
    </code></pre>

    <p>3. Create a new index.coffee file in <a href="#code/app/assets/javascripts" class="shortcut">/app/assets/javascripts</a> containing:</p>

    <pre><code>
        $ ->
            $("#queryForm").submit (event) ->
                event.preventDefault()
                query = $("#twitterQuery").val()
                $.get "/tweets?query=" + query, (data) ->
                    displayTweets(data)

            displayTweets = (tweets) ->
                $("#tweets").empty()
                $.each tweets.statuses, (index, tweet) ->
                    $("#tweets").append $("<li>").text(tweet.text)

    </code></pre>

    <p>4. Run the app, make a query, and verify the tweets show up: <a href="http://localhost:9000/tweets?query=typesafe" target="_blank">http://localhost:9000</a></p>
</div>

<div>
    <h2>Create an Akka Actor</h2>

    <p>1. Create a new UserActor.scala file in <a href="#code/app/actors" class="shortcut">/app/actors</a> containing:</p>

      <pre><code>

          package actors

          import akka.actor.{Props, Actor}
          import play.api.libs.json.JsValue
          import scala.concurrent.duration._
          import play.api.libs.concurrent.Execution.Implicits.defaultContext
          import controllers.Tweets

          class UserActor(tweetUpdate: JsValue => Unit, tickDuration:FiniteDuration) extends Actor {

              var maybeQuery: Option[String] = None

              val tick = context.system.scheduler.schedule(Duration.Zero, tickDuration, self, FetchTweets)

              def receive = {

              case FetchTweets =>
                  maybeQuery.map { query =>
                      Tweets.fetchTweets(query).map(tweetUpdate)
              }

              case message: JsValue =>
                  maybeQuery = (message \ "query").asOpt[String]
              }

              override def postStop() {
                  tick.cancel()
              }

          }

          case object FetchTweets

          object UserActor {

              def props(tweetUpdate: JsValue => Unit, tickDuration:FiniteDuration): Props =
                  Props(new UserActor(tweetUpdate, tickDuration))

          }
      </code></pre>

</div>

<div>
    <h2>Add Websockets</h2>

    <p>1. Add the following route to the  <a href="#code/conf/routes" class="shortcut">routes </a>file:</p>

    <p>GET &nbsp;&nbsp /ws     &nbsp;&nbsp;&nbsp;&nbsp;              controllers.Tweets.ws</p>

    <p>2. Add a new controller method in the <a href="#code/app/controllers/Tweets.scala" class="shortcut">Tweets.scala </a> file: app/controllers/Tweets.scala:</p>

    <pre><code>
        def ws = WebSocket.using[JsValue] { request =>
            val (out, channel) = Concurrent.broadcast[JsValue]

            val tickDuration = Duration(current.configuration.getMilliseconds("tickDuration").get, TimeUnit.MILLISECONDS)

            val userActor = Akka.system.actorOf(UserActor.props(channel.push, tickDuration))

            val in = Iteratee.foreach[JsValue](userActor ! _).map(_ => Akka.system.stop(userActor))

            (in, out)
        }
    </code></pre>

    <p>3. Replace the first line in <a href="#code/app/views/main.scala.html" class="shortcut">main.scala.html</a> with:</p>

       <pre><code> @(title: String)(content: Html)(implicit request: RequestHeader)</code></pre>

        <p>And replace the body tag with:</p>

        <pre><code> &ltbody data-ws="@routes.Tweets.ws.webSocketURL()"&gt</code></pre>


    <p>4. Update the <a href="#code/app/assets/javascripts/index.coffee" class="shortcut">index.coffee </a>file:</p>

    <pre><code>
        ws = new WebSocket $("body").data("ws")
            ws.onmessage = (event) ->
                data = JSON.parse event.data
                displayTweets(data)

        $("#queryForm").submit (event) ->
            event.preventDefault()
            query = $("#twitterQuery").val()
            ws.send JSON.stringify
                query: query
            $.get "/tweets?query=" + query, (data) ->
                displayTweets(data)

    </code></pre>

    <p>5. Add a config parameter to <a href="#code/conf/application.conf" class="shortcut">conf/application.conf</a></p>

    tickDuration = 15 seconds

</div>
<div>
    <h2>Add the Tweet Map</h2>

    <ul>
        <li>WebJars</li>
        <li>Less</li>
    </ul>

    <p>1. The webjar dependency on leaflets has already been added to <a href="#code/build.sbt" class="shortcut">build.sbt</a></p>

    <p>2. Include the Leaflet CSS and JS in the <a href="#code/app/views/main.scala.html" class="shortcut">main.scala.html </a>file:</p>

    <pre><code>
        &ltlink rel='stylesheet' href='@routes.WebJarAssets.at(WebJarAssets.locate("leaflet.css"))'&gt
        &ltscript type='text/javascript' src='@routes.WebJarAssets.at(WebJarAssets.locate("leaflet.js"))'&gt&lt/script&gt
    </code></pre>

    <p>3. Replace the &ltul&gt in app/views/index.scala.html with:</p>
    <pre><code>&lt;div id="map"&gt;&lt;/div&gt;</code></pre>

    <p>4. Add a stylesheets directory in <a href="#code/app/assets" class="shortcut">assets</a>

    <p>5. Add an <a href="#code/app/assets/stylesheets" class="shortcut">index.less </a> in the stylesheets directory with:</p>

    <pre><code>
    #map {
        position: absolute;
        top: 40px;
        bottom: 0px;
        left: 0px;
        right: 0px;
    }
    </code></pre>

    <p>6. Update the <a href="#code/app/assets/javascripts/index.coffee" class="shortcut">index.coffee </a> file with the following (replacing the displayTweets function):</p>

    <pre><code>
    map = L.map('map').setView([0, 0], 2)
    L.tileLayer('http://{s}.tile.osm.org/{z}/{x}/{y}.png', {}).addTo(map)

    displayTweets = (tweets) ->
        $.each tweets.statuses, (index, tweet) ->
            L.marker([tweet.coordinates.coordinates[1], tweet.coordinates.coordinates[0]])
                .addTo(map)
                .bindPopup(tweet.text)
                .openPopup()
    </code></pre>

    <p>7. Create new functions in the <a href="#code/app/controllers/Tweets.scala" class="shortcut">Tweets.scala</a> file:</p>

    <pre><code>
        private def putLatLonInTweet(latLon: JsValue) = __.json.update(__.read[JsObject].map(_ + ("coordinates" -> Json.obj("coordinates" -> latLon))))

        private def tweetLatLon(tweets: Seq[JsValue]): Future[Seq[JsValue]] = {
            val tweetsWithLatLonFutures = tweets.map { tweet =>

                if ((tweet \ "coordinates" \ "coordinates").asOpt[Seq[Double]].isDefined) {
                    Future.successful(tweet)
                } else {
                    val latLonFuture: Future[(Double, Double)] = (tweet \ "user" \ "location").asOpt[String].map(lookupLatLon).getOrElse(Future.successful(randomLatLon))
                    latLonFuture.map { latLon =>
                        tweet.transform(putLatLonInTweet(Json.arr(latLon._2, latLon._1))).getOrElse(tweet)
                    }
                }
            }

            Future.sequence(tweetsWithLatLonFutures)
        }

        private def randomLatLon: (Double, Double) = ((Random.nextDouble * 180) - 90, (Random.nextDouble * 360) - 180)

        private def lookupLatLon(query: String): Future[(Double, Double)] = {
            val locationFuture = WS.url("http://maps.googleapis.com/maps/api/geocode/json").withQueryString(
                "sensor" -> "false",
                "address" -> query
            ).get()

            locationFuture.map { response =>
                (response.json \\ "location").headOption.map { location =>
                    ((location \ "lat").as[Double], (location \ "lng").as[Double])
                }.getOrElse(randomLatLon)
            }
        }
    </code></pre>
    <p>8. In <a href="#code/app/controllers/Tweets.scala" class="shortcut">Tweets.scala</a> update the fetchTweets function to use the new tweetLatLon function:</p>

    <pre><code>
        def fetchTweets(query: String): Future[JsValue] = {
            val tweetsFuture = WS.url("http://twitter-search-proxy.herokuapp.com/search/tweets").withQueryString("q" -> query).get()
            tweetsFuture.flatMap { response =>
                tweetLatLon((response.json \ "statuses").as[Seq[JsValue]])
            } recover {
                case _ => Seq.empty[JsValue]
            } map { tweets =>
                Json.obj("statuses" -> tweets)
            }
        }
    </code></pre>
    <p>9. Refresh your browser to see the TweetMap!</p>
</div>
<div>
    <h2>Test the Controller</h2>

    <p>
    <ul>
        <li>Specs2</li>
        <li>Running the Tests</li>
        <li>Views</li>
        <li>Reactive Requests</li>
        <li>JSON</li>
    </ul>

    <p>Create a new test by adding the TweetsSpec.scala file in the <a href="#code/test" class="shortcut">test directory:</a></p>
    <pre><code>
        import org.specs2.mutable._
        import org.specs2.runner._
        import org.junit.runner._

        import play.api.libs.json.JsValue
        import play.api.test._
        import play.api.test.Helpers._

        @RunWith(classOf[JUnitRunner])
        class TweetsSpec extends Specification {

            "Application" should {
                "render index template" in new WithApplication {
                    val html = views.html.index("Coco")
                    contentAsString(html) must contain("Coco")
                }

                "render the index page" in new WithApplication{
                    val home = route(FakeRequest(GET, "/")).get

                    status(home) must equalTo(OK)
                    contentType(home) must beSome.which(_ == "text/html")
                    contentAsString(home) must contain ("TweetMap")
                }

                "search for tweets" in new WithApplication {
                    val search = controllers.Tweets.search("typesafe")(FakeRequest())

                    status(search) must equalTo(OK)
                    contentType(search) must beSome("application/json")
                    (contentAsJson(search) \ "statuses").as[Seq[JsValue]].length must beGreaterThan(0)
                }
            }
        }

    </code></pre>

    <p>2. Run the <a href="#test" class="shortcut">tests</a>

</div>

<div>
    <h2>Test the Actor</h2>

    <p>1. The akka-testkit dependency has already been added to <a href="#code/build.sbt" class="shortcut">build.sbt.</a> Notice that it specifies the scope as only being test.</p>

    <p>2. Create a new file in test/UserActorSpec.scala containing:</p>

     <pre><code>
         import actors.UserActor
         import akka.testkit.TestActorRef
         import org.specs2.mutable._
         import org.specs2.runner._
         import org.specs2.time.NoTimeConversions
         import org.junit.runner._

         import play.api.libs.concurrent.Akka
         import play.api.libs.json.{JsValue, Json}
         import play.api.test._

         import scala.concurrent.duration._
         import scala.concurrent.{Await, Promise}

         @RunWith(classOf[JUnitRunner])
         class UserActorSpec extends Specification with NoTimeConversions {

             "UserActor" should {

                 "fetch tweets" in new WithApplication {

                     implicit val actorSystem = Akka.system

                     val promiseJson = Promise[Seq[JsValue]]()
                     def validateJson(jsValue: JsValue) {
                        val tweets = (jsValue \ "statuses").as[Seq[JsValue]]
                        promiseJson.success(tweets)
                     }

                     val userActorRef = TestActorRef(new UserActor(validateJson, 1.second))

                     val querySearchTerm = "scala"
                     val jsonQuery = Json.obj("query" -> querySearchTerm)

                     userActorRef ! jsonQuery
                     userActorRef.underlyingActor.maybeQuery.getOrElse("") must beEqualTo(querySearchTerm)

                     Await.result(promiseJson.future, 10.seconds).length must beGreaterThan(1)

                 }
             }
         }
     </code></pre>

    <p>3. Run the <a href="#test" class="shortcut">tests</a> </p>
</div>
<!--
<div>
    <h2> Code Overview</h2>

    <p>A Play application has very few required files.  This example tries to illustrate a number of key concepts in Play so it has a handful of files to explain.  The <a href="#code/app" class="shortcut">app</a> directory contains the application's source code, including Java, Scala, server-side templates, and server-side compiled assets for the browser (e.g. JavaScript, CoffeeScript, LESS).  The <a href="#code/conf" class="shortcut">conf</a> directory contains the <a href="#code/conf/application.conf" class="shortcut">application.conf</a> config file and the <a href="#code/conf/routes" class="shortcut">routes</a> file</a>.  The <a href="#code/project" class="shortcut">project</a> directory contains the SBT build information for the app.  The default place for static assets (e.g. images, HTML, CSS, JavaScript) is the <a href="#code/public" class="shortcut">public</a> directory.  Unit, functional, and integration tests (Java and Scala) go in the <a href="#code/test" class="shortcut">test</a> directory.</p>
</div>
<div>
    <h2> HTTP Routing</h2>

    <p>
        The <a href="#code/conf/routes" class="shortcut">routes</a> file contains mappings between HTTP request verbs &amp; paths and the code that controller method that handles the requests.  Route paths can be parametrized to support RESTful style URLs.  The following mapping will handle HTTP GET requests to "/" using the <strong>controllers.Application.index</strong> method:
        <pre><code>GET   /    controllers.Application.index</code></pre>
        You can try out the routing by first making a request to an unmatched route, like: <a href="http://localhost:9000/foo" target="_blank">http://localhost:9000/foo</a><br/>
        This should produce an error because there isn't a route that matches the request.
        Then edit the <a href="#code/conf/routes" class="shortcut">routes</a> to include a new route:
        <pre><code>GET   /foo    controllers.Application.index</code></pre>
        Now retry the request and you should see the default index page.<br/>
        By default the routes are compiled by Play so that they can be used in a type-safe way.  This prevents issues caused by incorrect URL usages.
    </p>
</div>
<div>
    <h2> Controllers</h2>

    <p>
        HTTP GET requests to <a href="http://localhost:9000/" target="_blank">http://localhost:9000/</a> are handled by the index method defined in the <a href="#code/app/controllers/Application.java" class="shortcut">Application.java</a> file.  This static method returns a <strong>Result</strong> which in this case consists of a server-side rendered template and an HTTP 200 response which is represented by the <strong>ok</strong> method call.  You can also use non-static methods along with Dependency Injection frameworks like Spring, Guice, and CDI.<br/> 
        You can change the "Hello Play Framework" string in <a href="#code/app/controllers/Application.java" class="shortcut">Application.java</a> a different value, like "Hello from Play", then save the file and reload <a href="http://localhost:9000/" target="_blank">the index page</a> in your browser.  Play will automatically recompile the controller and you should immediately see your changes.<br/>
        If your changes result in a compile error you will see the error in your browser (after a refresh) and in the <a href="#compile" class="shortcut">Compile Plugin</a>.  Try it by removing one of the double-quotes in the <strong>index</strong> method's string, save the file, and reload the index page.  Fix the error before you continue.<br/>
    </p>
</div>
<div>
    <h2> Templates</h2>

    <p>
        The <strong>Application.index</strong> method uses a template which is compiled by Play into a function.  The source is in the <a href="#code/app/views/index.scala.html" class="shortcut">index.scala.html</a> file and is available by calling the <strong>views.html.index.render</strong> function.  This template takes a parameter of a <strong>String</strong> so the compiled function also takes a <strong>String</strong> parameter.  The default templating language in Play is Scala, but a number of other templating languages (like Java, Groovy, and Dust) can also be plugged in.<br/>
        The <a href="#code/app/views/index.scala.html" class="shortcut">index template</a> uses the <a href="#code/app/views/main.scala.html" class="shortcut">main template</a> by calling the <strong>main</strong> function with the required parameters.<br/>
        Notice that the templates do not use hard-coded URLs and instead use Play's reverse routing, like:
        <pre><code>@routes.Assets.at("images/favicon.png")</code></pre>
        This provides a type-safe way to specify URLs in an application.  If the URL to a file changes, then automatically, the new value will be used throughout all of the URL references.  You can use the reverse router anywhere in your code, like redirects in controllers.<br/>
        Like controllers (and all source code in Play) you can make changes to templates which triggers a recompile.  Then simply refresh the page to see the changes.  Try it out by making a change to the <a href="#code/app/views/index.scala.html" class="shortcut">index template</a>, saving the file, and then refreshing the <a href="http://localhost:9000/" target="_blank">index page</a> in your browser.
    </p>
</div>
<div>
    <h2> Static Assets</h2>

    <p>
        This application has a route to handle loading static assets from the <a href="#code/public" class="shortcut">public</a> directory:
        <pre><code>GET /assets/*file controllers.Assets.at(path="/public", file)</code></pre>
        A request to <a href="http://localhost:9000/assets/images/favicon.png" target="_blank">http://localhost:9000/assets/images/favicon.png</a> will use this route to find the <a href="#code/public/images/favicon.png" class="shortcut">favicon.png</a> file in the <strong>public/images</strong> directory.<br/>
        You can put any static assets into the public directory and have them accessible in this way.
    </p>
</div>
<div>
    <h2> Test the App</h2>

    <p>
        This application includes a number of tests which are automatically run after each successful compile.  You can see the test results in the <a href="#test" class="shortcut">Test plugin</a>.  Due to changes that you may have made to your application source code, some of the tests might now be failing.  The source for the tests is located in the <a href="#code/test" class="shortcut">test</a> directory.  The <a href="#code/test/ApplicationTest.java" class="shortcut">test/ApplicationTest.java</a> Java class contains a number of unit and functional tests for the <strong>Application</strong>.  The <a href="#code/test/IntegrationTest.java" class="shortcut">IntegrationTest.java</a> file contains an test which uses Solenium to test the actual UI in a browser.  The default testing framework for Java in Play is JUnit, but you can plug any testing framework in.<br/>
        If you modify a test and save the changes, then the tests will automatically be re-run.
    </p>
</div>
<div>
    <h2> SBT Build</h2>

    <p>
        SBT is the build system underneath Play applications.  It is responsible for resolving dependencies, compiling the project, running the tests, etc.  The primary build definition file is the <a href="#code/project/Build.scala" class="shortcut">Build.scala</a> file.  In that file you will see a comma-seperated list of dependencies which can be modified to suit your needs.  Play includes a number of libraries which can selectively be turned on/off.  For instance if you want to use JPA with Play, uncomment the <strong>javaJpa</strong> dependency.  You can also add your own dependencies in the SBT form:
        <pre><code>"group" % "artifact" % "version"</code></pre>
    </p>
</div>
-->
<div>
    <h2> Further Learning</h2>

    <p>
        The <a href="http://www.playframework.com/documentation" target="_blank">Play Documentation</a> contains much
        more exhaustive details and also covers a number of other topics which haven't been addressed in this
        tutorial.<br/>
        <a href="http://stackoverflow.com" target="_blank">StackOverflow</a> is a great place ask questions about
        Play.<br/>
        <a href="http://groups.google.com/group/play-framework" target="_blank">The play-framework</a> Google Group is a
        great place to discuss Play.<br/>
    </p>
</div>
</body>
</html>
